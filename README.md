                                                                                                _                                
                                     ğŸ˜                             _ __    _   _    ___   ___  | |_   _ __    __ _               ğŸ’¥                           ğŸ˜
                       ğŸ’¦                                          | '_ \  | | | |  / _ \ / __| | __| | '__|  / _` |              
                                                                   | | | | | |_| | |  __/ \__ \ | |_  | |    | (_| |                                         ğŸ’‹
                                                                   |_| |_|  \__,_|  \___| |___/  \__| |_|     \__,_|                                                     ğŸ§š
                                                         _ __    __ _   ____   /_/    _ __                             
                              ğŸ’¥                       | '__|  / _` | |_  /  / _ \  | '_ \                            ğŸ’«
                                                        | |    | (_| |  / /  | (_) | | | | |                           
     ğŸ’«                                                |_|     \__,_| /___|  \___/  |_| |_|                                                        ğŸ˜
                                                                       __                                        _   _____ 
                                                             _ __    _/_/_   _ __ ___     ___   _ __    ___     / | |___ / 
                        ğŸ‘…                                  | '_ \  | | | | | '_ ` _ \   / _ \ | '__|  / _ \    | |   |_ \                 ğŸ’¦
                                             ğŸ§š             | | | | | |_| | | | | | | | |  __/ | |    | (_) |   | |  ___) |                                                             
             ğŸ’‹                                             |_| |_|  \__,_| |_| |_| |_|  \___| |_|     \___/    |_| |____/                                                          ğŸ‘…

                                                                                                                  coquetteğŸ’‹
                                                                                                                  
                                                                                                                  
                                                                                                                  
Trastocados por este proyecto: Alejandro Serrano, Ãngela VinuÃ©s y Alba Prats
>[!TIP]
>ğŸ˜Si te rÃ­es tienes menos posibilidades de dejar la carrerağŸ’‹                                                                                                                
<br />
<br />

>[!WARNING]
>La mayorÃ­a de dÃ­as hemos quedado para hacer el proyecto juntos, la cantidad de horas, aparte de las que cada uno haya usado fuera de quedar, las hemos hecho a la vez, teniendo por lo tanto mÃ¡s o menos las mismas horas cada uno y teniendo en cuenta que dentro de ese tiempo nos hemos ayudado mutuamente si era necesario.

<br />
<br />
ğ’‰ğ’†ğ’ğ’ğ’” ğ’”ğ’Šğ’…ğ’ ğ’–ğ’•ğ’Šğ’ğ’†ğ’”??????
<br />
<br />
ğŸ¬  ğŸ“  ğŸ€  ğ’¶ğ“ğ‘’ğ’¿ğ’¶ğ“ƒğ’¹ğ“‡ğ‘œ  ğŸ€  ğŸ“  ğŸ¬ <br />
Este hombretÃ³n ha usado 61 horas de su vida muy bien optimizadas y muy eficientes en programar el main, las funciones colosales writeUserInfo, readUserInfo y checksum.<br />
(ã£â—”â—¡â—”)ã£ â™¥ menciones especiales â™¥<br />
&nbsp -> El porcentaje de horas que las ha usado llorando es menor al 20%, una persona âœ¨espectacularâœ¨<br />
&nbsp -> Arreglador de errores oficial, decidimos parar el cronÃ³metro cada vez que este tio se metÃ­a al debugger, si no serÃ­an ğŸŒˆâœ¨180 horasğŸŒˆâœ¨<br />
Desde luego, no ha usado 2 horas en programar una funciÃ³n inutil.<br />
<br />
ğŸ¤¡  ğŸ’…  ğŸ¥€  ğ’¶ğ“ğ’·ğ’¶  ğŸ¥€  ğŸ’…  ğŸ¤¡ <br />
Tremendas 58+2 horas bien usadas. Prefiero no decir en quÃ© he usado esas 2 horasğŸ’”. Pero sÃ­ que he hecho semejante README y las funciones createUserInfo, fillUserInfo y deleteUser. Por hacer tambiÃ©n he hecho el payaso aprendiendo C# para una interfaz grÃ¡fica ğŸ’”mediocreğŸ’” <br />
(ã£â—”â—¡â—”)ã£ â™¥ menciones especiales â™¥<br />
&nbsp -> Me he peleado a muerte cocn el GTK / MSYS2 y he perdido.<br />
&nbsp -> Tampoco me ha salido tan mal la interfaz pobrecita tio. ğ˜†ğ—¼ ğ—°ğ—¿ğ—²ğ—¼ ğ—¾ğ˜‚ğ—² ğ˜€ğ—² ğ—±ğ—²ğ—¯ğ—²ğ—¿Ã­ğ—® ğ˜ğ—²ğ—»ğ—²ğ—¿ ğ—²ğ—» ğ—°ğ—¼ğ—»ğ˜€ğ—¶ğ—±ğ—²ğ—¿ğ—®ğ—°ğ—¶Ã³ğ—».<br />
&nbsp -> Mi playlist mientras hacÃ­a la prÃ¡ctica es un indicador de la poca cordura que me queda. DeberÃ­as mirarla Enrique: https://open.spotify.com/playlist/2uaRgBelBf1BsxWrleTMZ5?si=5iBgmja1TJeC3hxi-LgvrQ&utm_source=copy-link<br />
<br />
ğŸ—¿  ğŸ‘»  ğŸ’„  ğ’¶ğ“ƒğ‘”ğ‘’ğ“ğ’¶  ğŸ’„  ğŸ‘»  ğŸ—¿ <br />
ğŸ·ğŸ› 56 pedazo de horas, tiene mÃ©rito programar mientras lloras. Estamos muy orgullosos de lo que ha hecho: ambas cabeceras y las funciones XORCifrado, freeAllUserInfo y freeUserInfo. ğŸ‘ <br />
(ã£â—”â—¡â—”)ã£ â™¥ menciones especiales â™¥<br />
&nbsp -> La memoria tÃ©cnica no serÃ­a nada sin ella. <br />
&nbsp -> Como buena usuaria promedio, reventÃ³ el programa escribiendo su nombre. <br />
<br />
<br />
Y ahora, la secciÃ³n ğŸ€ğŸ’Ÿğ“ºğ“¾ğ“® ğ“¬ğ“¸ğ“³ğ“¸ğ“·ğ“®ğ“¼ ğ“®ğ“¼ ğ“®ğ“¼ğ“¸ğŸ˜â¤ï¸
<br />
<br />
ğŸ–•  ğŸ’¢  ğŸ˜   ğ“ğ’¾ğ’·ğ“‡ğ‘’ğ“‡ğ’¾ğ’¶/ğ’¸ğ’¶ğ’·ğ‘’ğ’¸ğ‘’ğ“‡ğ’¶ ğ’»ğ’¾ğ“ğ‘’ğ“ˆ  ğŸ˜   ğŸ’¢  ğŸ–•<br />
Esta librerÃ­a alberga dos funciones dirigidas hacia la creaciÃ³n/gestiÃ³n de ficheros.
<br />
<br />
ğ™ğ™ªğ™£ğ™˜ğ™Ã³ğ™£ ğ™¬ğ™§ğ™ğ™©ğ™šğ™ğ™¨ğ™šğ™§ğ™„ğ™£ğ™›ğ™¤<br />
Objetivo -> escribir informaciÃ³n introducida por el usuario en un fichero, cifrÃ¡ndola mediante una llamada a una funciÃ³n privada para la librerÃ­a que realiza el cifrado/descifrado XOR.<br /> 
<br />
ParÃ¡metros -> â€œchar* pathâ€ es un puntero a una cadena de caracteres que indica la ruta del archivo. â€œConst userInfo* usersâ€ es un puntero a un struct definido en la segunda librerÃ­a. â€œInt* numUserPairsâ€ es un puntero a una variable que almacena la cantidad de usuarios y contraseÃ±as que se van a escribir. â€œConst char* encryptionKeyâ€ es un puntero a una cadena con la clave utilizada para cifrar la informaciÃ³n.<br />
<br />
La funciÃ³n comienza abriendo un archivo binario en modo de escritura (gestionando posibles errores). Tras haber reservado memoria para dos cadenas que contendrÃ¡n la informaciÃ³n antes y despuÃ©s del cifrado, la funciÃ³n las construye incluyendo la cantidad de usuarios, longitudes de nombres de usuario y contraseÃ±as y los propios nombres de usuario y contraseÃ±a. La adiciÃ³n del carÃ¡cter â€œ|â€ en la cadena cifrada tiene el propÃ³sito de actuar como un separador entre las diferentes partes de la informaciÃ³n. Finalmente, escribe la cadena cifrada en el archivo y cierra el archivo. La funciÃ³n devuelve 1 en caso de Ã©xito y 0 si hay algÃºn error.<br />
<br />
<br />
ğ™ğ™ªğ™£ğ™˜ğ™Ã³ğ™£ ğ™§ğ™šğ™–ğ™™ğ™ğ™¨ğ™šğ™§ğ™„ğ™£ğ™›ğ™¤<br />
Objetivo -> leer informaciÃ³n previamente introducida por el usuario en un fichero binario cifrado, descifrÃ¡ndola mediante una llamada a una funciÃ³n privada para la librerÃ­a que realiza el cifrado/descifrado XOR.<br />
<br />
ParÃ¡metros -> â€œchar* pathâ€ es un puntero a una cadena de caracteres que indica la ruta del archivo. â€œInt* numUserPairsâ€ es un puntero a una variable que almacena  la cantidad de usuarios y contraseÃ±as que se van a escribir. â€œConst char* encryptionKeyâ€ es un puntero a una cadena con la clave utilizada para descifrar la informaciÃ³n.<br />
<br />
La funciÃ³n comienza abriendo un archivo binario en modo de lectura (gestionando posibles errores), en este caso, se ha utilizado un buffer de 1024 bytes para leer el archivo, imprimiÃ©ndolo en la consola. Posteriormente, tras descifrar las cadenas y asignarles memoria, se extraen el nÃºmero de pares de usuarios, nombres y contraseÃ±as y sus respectivas longitudes. Por Ãºltimo, se le asigna memoria al struct y se cierra el fichero.<br />
<br />
<br />
ğ™ğ™ªğ™£ğ™˜ğ™Ã³ğ™£ ğ™“ğ™Šğ™ğ˜¾ğ™ğ™›ğ™§ğ™–ğ™™ğ™¤<br />
Objetivo -> implementar un cifrado XOR a una cadena con una clave.<br />
<br />
ParÃ¡metros -> esta funciÃ³n requiere un puntero a la cadena de datos a cifrar, un puntero a la clave usada, la longitud de ambos parÃ¡metros anteriores y un puntero a una cadena donde alojar la informaciÃ³n cifrada.<br />
<br />
La funciÃ³n consiste en un Ãºnico bucle donde cada byte de la cadena a cifrar se combina con el byte correspondiente de la clave utilizando la operaciÃ³n XOR (^).<br />
<br />
<br />
ğ™ğ™ªğ™£ğ™˜ğ™Ã³ğ™£ ğ™˜ğ™ğ™šğ™˜ğ™ ğ™¨ğ™ªğ™¢<br />
Esta funciÃ³n calcula el checksum (valor numÃ©rico que se calcula a partir de un conjunto de datos con el objetivo de verificar su integridad) de datos introducidos por el usuario.<br />
<br />
ParÃ¡metros -> esta funciÃ³n requiere de un puntero a una cadena de bytes sobre la que se calcularÃ¡ el checksum y su tamaÃ±o.<br />
<br />
La funciÃ³n consiste en un Ãºnico bucle donde se recorre el array de bytes y se calcula el checksum.<br />
<br />
<br />
ğŸ–•  ğŸ’¢  ğŸ˜   ğ“ğ’¾ğ’·ğ“‡ğ‘’ğ“‡ğ’¾ğ’¶/ğ’¸ğ’¶ğ’·ğ‘’ğ’¸ğ‘’ğ“‡ğ’¶ ğ“Šğ“ˆğ‘’ğ“‡ğ¼ğ“ƒğ’»ğ‘œ  ğŸ˜   ğŸ’¢  ğŸ–•<br />
Esta librerÃ­a alberga dos funciones dirigidas hacia la creaciÃ³n/gestiÃ³n de ficheros.
<br />
<br />
ğ™ğ™ªğ™£ğ™˜ğ™Ã³ğ™£ ğ™˜ğ™§ğ™šğ™–ğ™©ğ™šğ™ğ™¨ğ™šğ™§ğ™„ğ™£ğ™›ğ™¤<br />
Objetivo ->  asignar dinÃ¡micamente memoria para structs y devuelve un puntero a la memoria asignada.<br />
<br />
ParÃ¡metros -> esta funciÃ³n solo requiere del nÃºmero inicial de structs a los cuales se les asignarÃ¡ memoria.<br />
<br />
<br />
ğ™ğ™ªğ™£ğ™˜ğ™Ã³ğ™£ ğ™›ğ™ğ™¡ğ™¡ğ™ğ™¨ğ™šğ™§ğ™„ğ™£ğ™›ğ™¤<br />
Objetivo -> que el usuario introduzca los datos de una nueva cuenta, almacenÃ¡ndolos en una estructura del tipo â€œuserInfoâ€.<br />
<br />
ParÃ¡metros -> esta funciÃ³n solo requiere un puntero a un struct â€œuserInfoâ€.<br />
<br />
La funciÃ³n comienza pidiendo al usuario que introduzca un nombre de usuario y contraseÃ±a para posteriormente rellenar el struct con la informaciÃ³n aportada, reservando memoria para ello.<br />
<br />
<br />
ğ™ğ™ªğ™£ğ™˜ğ™Ã³ğ™£ ğ™›ğ™§ğ™šğ™šğ˜¼ğ™¡ğ™¡ğ™ğ™¨ğ™šğ™§ğ™„ğ™£ğ™›ğ™¤<br />
Objetivo -> liberar toda memoria no usada tras asignarla dinÃ¡micamente en funciones anteriores.<br />
<br />
ParÃ¡metros -> esta funciÃ³n requiere de un puntero a un struct â€œuserInfoâ€ y la cantidad de nombres de usuario y contraseÃ±as creadas.<br />
<br />
La funciÃ³n consiste en un Ãºnico bucle donde se llama a una funciÃ³n auxiliar donde se libera la memoria no utilizada al introducir el nombre de usuario y la contraseÃ±a dentro de un struct. <br />
<br />
<br />
ğ™ğ™ªğ™£ğ™˜ğ™Ã³ğ™£ ğ™™ğ™šğ™¡ğ™šğ™©ğ™šğ™ğ™¨ğ™šğ™§<br />
Objetivo -> eliminar un determinado usuario, ocupando el espacio en caso de quedar libre con el resto de los elementos del array.<br />
<br />
ParÃ¡metros -> esta funciÃ³n requiere de un puntero a un struct â€œuserInfoâ€ y la cantidad de nombres de usuario y contraseÃ±as creadas, ademÃ¡s del Ã­ndice que el usuario quiere borrar.<br />
<br />
La funciÃ³n comienza verificando si el Ã­ndice introducido por el usuario es un Ã­ndice vÃ¡lido, para despuÃ©s llamar a la funciÃ³n freeUserInfo para liberar la memoria del usuario ocupando el Ã­ndice a borrar. Tras reorganizar el array y restarle 1 al nÃºmero de nombres de usuario, se ajusta la memoria asignada al array al nuevo nÃºmero de usuarios.<br />
<br />
<br />
Por Ãºltimo, la secciÃ³n ğŸ€ğŸ’Ÿğ“ºğ“¾ğ“® ğ“¹ğ“®ğ“µğ“¸ğ“½ğ“ªğ“¼ ğ“®ğ“¼ğ“½ğ“¸ğ”‚ ğ“±ğ“ªğ“¬ğ“²ğ“®ğ“·ğ“­ğ“¸ğŸ˜â¤ï¸
<br />
âœ¨la mierda de interfaz grÃ¡ficaâœ¨
<br />
<br />
En primer lugar, para empezar con esta interfaz, se aÃ±adirÃ¡n un par de etiquetas donde se escribirÃ¡ â€œIntroduce su usuario/contraseÃ±aâ€, acompaÃ±adas de un par de cuadros de texto donde el usuario lo introducirÃ¡ y un botÃ³n que confirme la acciÃ³n. <br />
<br />
Se quiere que determinadas partes del cÃ³digo permanezcan ocultas hasta que se haya realizado alguna acciÃ³n (se le de clic al botÃ³n de confirmar de â€œIntroduce su usuarioâ€, por ejemplo), por lo que cambiaremos desde el cuadro de la derecha la propiedad â€œVisibilidadâ€ de los tres objetos que queremos inicialmente ocultos a â€œFalsoâ€.<br />
<br />
Al hacer click al objeto que queremos que ejecute cÃ³digo aparecerÃ¡ el lugar donde introducir ese respectivo cÃ³digo. Aparecen 4 ficheros diferentes, el entorno grÃ¡fico que ya se ha visto, â€œForm1.csâ€, donde se almacena el cÃ³digo del entorno grÃ¡fico, â€œForm1.Designerâ€ traduce automÃ¡ticamente a cÃ³digo las acciones que se realizan en el entorno grÃ¡fico como arrastrar un botÃ³n a una determinada posiciÃ³n, cambiar propiedades, etc. â€œProgram.csâ€ serÃ­a un equivalente al main de Clion, es el lugar donde se declaran variables globales y se aloja el cÃ³digo que lanza en primer lugar el formulario. En cuanto a las variables globales, estas van definidas dentro de una clase.<br />
<br />
<br />
ğŸ€ğŸ’Ÿğ“±ğ“ªğ“¬ğ“²ğ“®ğ“·ğ“­ğ“¸ ğ“®ğ“¼ğ“½ğ“¸ ğ“­ğ“® ğ“ªğ“«ğ“ªğ“³ğ“¸ ğ“·ğ“¾ğ“·ğ“¬ğ“ª ğ“±ğ“® ğ“½ğ“®ğ“·ğ“²ğ“­ğ“¸ ğ“¶ğ“ªğ“¼ ğ“°ğ“ªğ“·ğ“ªğ“¼ ğ“­ğ“® ğ“¶ğ“®ğ“½ğ“®ğ“» ğ“µğ“ª ğ“¬ğ“ªğ“«ğ“®ğ”ƒğ“ª ğ“ªğ“µ ğ“¶ğ“²ğ“¬ğ“»ğ“¸ğ“¸ğ“·ğ“­ğ“ªğ“¼ğŸ˜â¤ï¸
<br />
<br />
Primero, es importante mencionar que la interfaz grÃ¡fica no estÃ¡ completa por errores de falta de conocimiento sobre C#, interfaces grÃ¡ficas y Visual Studio. EstÃ¡ completo y funciona el bloque de cÃ³digo de crear el fichero, aÃ±adir usuarios, listar usuarios y guardar y salir. No comprueba la contraseÃ±a maestra, existen errores en el borrado de cuentas, no calcula el checksum ni cifra. <br />
<br />
Tras aÃ±adir librerÃ­as se inicializa el Form y esta espera interacciones. La primera interacciÃ³n posible es el botÃ³n â€œOKâ€ para introducir el usuario maestro, si no se ha introducido texto en el cuadro de texto, el programa no continÃºa y aparece una etiqueta que vuelve a preguntar por el usuario. Si por el contrario se ha introducido texto, se vuelven visibles una serie de etiquetas, cuadros de texto y botones que piden la contraseÃ±a maestra. Nuevamente, al darle a â€œOKâ€ tras introducirla se continÃºa con el programa, volviendo invisibles los objetos usados anteriormente.<br />
<br />
Tras comprobar la existencia del fichero, lo abre en modo lectura. La lÃ³gica de esta parte del cÃ³digo y de otras varias es muy parecida si no igual a la presentada en C en Clion, traducida a C#. En esta parte del cÃ³digo aparecen varios â€œMessageBoxâ€ y otras cosas que sirven para depurar. Si el fichero no existe, lo crea y aÃ±ade en la primera lÃ­nea el usuario y la contraseÃ±a maestras, separadas por un carÃ¡cter â€œ/â€, ademÃ¡s de volver visibles las siguientes partes del programa: listar, aÃ±adir y borrar usuarios y salir.<br />
<br />
Posteriormente, aparece un intento de cifrado con la misma funcionalidad XOR que no se ha logrado implementar por incapacidad de convertir los tipos de datos para que â€œ%â€ y â€œ^â€ funcionen.<br />
<br />
Por Ãºltimo, tenemos el desarrollo de la lÃ³gica de cada opciÃ³n disponible. Esta lÃ³gica es muy parecida a la que se ha visto en C, aÃ±adiendo partes de cÃ³digo propias de C#, â€œtraduciendoâ€ un lenguaje a otro.<br />
<br />
â€œListar Usuariosâ€ abre un listBox y presenta los usuarios aÃ±adidos. El programa lee lÃ­nea a lÃ­nea, y deshecha a partir del carÃ¡cter separador â€œ/â€ para que no aparezcan las contraseÃ±as.<br /> 
<br />
â€œAÃ±adir Usuarioâ€ lee el fichero, aÃ±ade la informaciÃ³n introducida por el usuario en objetos ya utilizados previamente (cambiando las etiquetas) y cierra el fichero. El programa, al leer informaciÃ³n la almacena en una cadena de strings llamado â€œlÃ­neasâ€. Al escribirlo en el fichero es vital aÃ±adir un salto de lÃ­nea para que se almacene un solo usuario/contraseÃ±a por lÃ­nea.<br />
<br />
â€œBorrar Usuarioâ€ permite seleccionar un usuario del listBox y lo borra. Sin embargo, aÃ±ade un usuario mÃ¡s al final del fichero. Este bloque de cÃ³digo se nos ha dificultado mÃ¡s, y no se ha podido corregir el error por falta de conocimientos.<br />
<br />
â€œGuardar y salirâ€ sale del programa.
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
muchas gracias Enrique por ser tan buen profe <3. has sido maravilloso, ojalÃ¡ todos tuvieran tanta suerte como nosotros y su primer contacto con la universidad sea tan maravilloso. realmente te tenemos mucho cariÃ±o, ojalÃ¡ todo te salga bien. muak, alejandro, Ã¡ngela y alba. 
<br />
<br />
gracias a tÃ­ nuestra razÃ³n nÃºmero 13 es mÃ¡s 12,5

