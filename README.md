                                                                                                _                                
                                     😍                             _ __    _   _    ___   ___  | |_   _ __    __ _               💥                           😍
                       💦                                          | '_ \  | | | |  / _ \ / __| | __| | '__|  / _` |              
                                                                   | | | | | |_| | |  __/ \__ \ | |_  | |    | (_| |                                         💋
                                                                   |_| |_|  \__,_|  \___| |___/  \__| |_|     \__,_|                                                     🧚
                                                         _ __    __ _   ____   /_/    _ __                             
                              💥                       | '__|  / _` | |_  /  / _ \  | '_ \                            💫
                                                        | |    | (_| |  / /  | (_) | | | | |                           
     💫                                                |_|     \__,_| /___|  \___/  |_| |_|                                                        😍
                                                                       __                                        _   _____ 
                                                             _ __    _/_/_   _ __ ___     ___   _ __    ___     / | |___ / 
                        👅                                  | '_ \  | | | | | '_ ` _ \   / _ \ | '__|  / _ \    | |   |_ \                 💦
                                             🧚             | | | | | |_| | | | | | | | |  __/ | |    | (_) |   | |  ___) |                                                             
             💋                                             |_| |_|  \__,_| |_| |_| |_|  \___| |_|     \___/    |_| |____/                                                          👅

                                                                                                                  coquette💋
                                                                                                                  
                                                                                                                  
                                                                                                                  
Trastocados por este proyecto: Alejandro Serrano, Ángela Vinués y Alba Prats
>[!TIP]
>😍Si te ríes tienes menos posibilidades de dejar la carrera💋                                                                                                                
<br />
<br />

>[!WARNING]
>La mayoría de días hemos quedado para hacer el proyecto juntos, la cantidad de horas, aparte de las que cada uno haya usado fuera de quedar, las hemos hecho a la vez, teniendo por lo tanto más o menos las mismas horas cada uno y teniendo en cuenta que dentro de ese tiempo nos hemos ayudado mutuamente si era necesario.

<br />
<br />
𝒉𝒆𝒎𝒐𝒔 𝒔𝒊𝒅𝒐 𝒖𝒕𝒊𝒍𝒆𝒔??????
<br />
<br />
🐬  🐓  🎀  𝒶𝓁𝑒𝒿𝒶𝓃𝒹𝓇𝑜  🎀  🐓  🐬 <br />
Este hombretón ha usado 61 horas de su vida muy bien optimizadas y muy eficientes en programar el main, las funciones colosales writeUserInfo, readUserInfo y checksum.<br />
(っ◔◡◔)っ ♥ menciones especiales ♥<br />
&nbsp -> El porcentaje de horas que las ha usado llorando es menor al 20%, una persona ✨espectacular✨<br />
&nbsp -> Arreglador de errores oficial, decidimos parar el cronómetro cada vez que este tio se metía al debugger, si no serían 🌈✨180 horas🌈✨<br />
Desde luego, no ha usado 2 horas en programar una función inutil.<br />
<br />
🤡  💅  🥀  𝒶𝓁𝒷𝒶  🥀  💅  🤡 <br />
Tremendas 58+2 horas bien usadas. Prefiero no decir en qué he usado esas 2 horas💔. Pero sí que he hecho semejante README y las funciones createUserInfo, fillUserInfo y deleteUser. Por hacer también he hecho el payaso aprendiendo C# para una interfaz gráfica 💔mediocre💔 <br />
(っ◔◡◔)っ ♥ menciones especiales ♥<br />
&nbsp -> Me he peleado a muerte cocn el GTK / MSYS2 y he perdido.<br />
&nbsp -> Tampoco me ha salido tan mal la interfaz pobrecita tio. 𝘆𝗼 𝗰𝗿𝗲𝗼 𝗾𝘂𝗲 𝘀𝗲 𝗱𝗲𝗯𝗲𝗿í𝗮 𝘁𝗲𝗻𝗲𝗿 𝗲𝗻 𝗰𝗼𝗻𝘀𝗶𝗱𝗲𝗿𝗮𝗰𝗶ó𝗻.<br />
&nbsp -> Mi playlist mientras hacía la práctica es un indicador de la poca cordura que me queda. Deberías mirarla Enrique: https://open.spotify.com/playlist/2uaRgBelBf1BsxWrleTMZ5?si=5iBgmja1TJeC3hxi-LgvrQ&utm_source=copy-link<br />
<br />
🗿  👻  💄  𝒶𝓃𝑔𝑒𝓁𝒶  💄  👻  🗿 <br />
🎷🐛 56 pedazo de horas, tiene mérito programar mientras lloras. Estamos muy orgullosos de lo que ha hecho: ambas cabeceras y las funciones XORCifrado, freeAllUserInfo y freeUserInfo. 👏 <br />
(っ◔◡◔)っ ♥ menciones especiales ♥<br />
&nbsp -> La memoria técnica no sería nada sin ella. <br />
&nbsp -> Como buena usuaria promedio, reventó el programa escribiendo su nombre. <br />
<br />
<br />
Y ahora, la sección 🎀💟𝓺𝓾𝓮 𝓬𝓸𝓳𝓸𝓷𝓮𝓼 𝓮𝓼 𝓮𝓼𝓸😍❤️
<br />
<br />
🖕  💢  😠  𝓁𝒾𝒷𝓇𝑒𝓇𝒾𝒶/𝒸𝒶𝒷𝑒𝒸𝑒𝓇𝒶 𝒻𝒾𝓁𝑒𝓈  😠  💢  🖕<br />
Esta librería alberga dos funciones dirigidas hacia la creación/gestión de ficheros.
<br />
<br />
𝙁𝙪𝙣𝙘𝙞ó𝙣 𝙬𝙧𝙞𝙩𝙚𝙐𝙨𝙚𝙧𝙄𝙣𝙛𝙤<br />
Objetivo -> escribir información introducida por el usuario en un fichero, cifrándola mediante una llamada a una función privada para la librería que realiza el cifrado/descifrado XOR.<br /> 
<br />
Parámetros -> “char* path” es un puntero a una cadena de caracteres que indica la ruta del archivo. “Const userInfo* users” es un puntero a un struct definido en la segunda librería. “Int* numUserPairs” es un puntero a una variable que almacena la cantidad de usuarios y contraseñas que se van a escribir. “Const char* encryptionKey” es un puntero a una cadena con la clave utilizada para cifrar la información.<br />
<br />
La función comienza abriendo un archivo binario en modo de escritura (gestionando posibles errores). Tras haber reservado memoria para dos cadenas que contendrán la información antes y después del cifrado, la función las construye incluyendo la cantidad de usuarios, longitudes de nombres de usuario y contraseñas y los propios nombres de usuario y contraseña. La adición del carácter “|” en la cadena cifrada tiene el propósito de actuar como un separador entre las diferentes partes de la información. Finalmente, escribe la cadena cifrada en el archivo y cierra el archivo. La función devuelve 1 en caso de éxito y 0 si hay algún error.<br />
<br />
<br />
𝙁𝙪𝙣𝙘𝙞ó𝙣 𝙧𝙚𝙖𝙙𝙐𝙨𝙚𝙧𝙄𝙣𝙛𝙤<br />
Objetivo -> leer información previamente introducida por el usuario en un fichero binario cifrado, descifrándola mediante una llamada a una función privada para la librería que realiza el cifrado/descifrado XOR.<br />
<br />
Parámetros -> “char* path” es un puntero a una cadena de caracteres que indica la ruta del archivo. “Int* numUserPairs” es un puntero a una variable que almacena  la cantidad de usuarios y contraseñas que se van a escribir. “Const char* encryptionKey” es un puntero a una cadena con la clave utilizada para descifrar la información.<br />
<br />
La función comienza abriendo un archivo binario en modo de lectura (gestionando posibles errores), en este caso, se ha utilizado un buffer de 1024 bytes para leer el archivo, imprimiéndolo en la consola. Posteriormente, tras descifrar las cadenas y asignarles memoria, se extraen el número de pares de usuarios, nombres y contraseñas y sus respectivas longitudes. Por último, se le asigna memoria al struct y se cierra el fichero.<br />
<br />
<br />
𝙁𝙪𝙣𝙘𝙞ó𝙣 𝙓𝙊𝙍𝘾𝙞𝙛𝙧𝙖𝙙𝙤<br />
Objetivo -> implementar un cifrado XOR a una cadena con una clave.<br />
<br />
Parámetros -> esta función requiere un puntero a la cadena de datos a cifrar, un puntero a la clave usada, la longitud de ambos parámetros anteriores y un puntero a una cadena donde alojar la información cifrada.<br />
<br />
La función consiste en un único bucle donde cada byte de la cadena a cifrar se combina con el byte correspondiente de la clave utilizando la operación XOR (^).<br />
<br />
<br />
𝙁𝙪𝙣𝙘𝙞ó𝙣 𝙘𝙝𝙚𝙘𝙠𝙨𝙪𝙢<br />
Esta función calcula el checksum (valor numérico que se calcula a partir de un conjunto de datos con el objetivo de verificar su integridad) de datos introducidos por el usuario.<br />
<br />
Parámetros -> esta función requiere de un puntero a una cadena de bytes sobre la que se calculará el checksum y su tamaño.<br />
<br />
La función consiste en un único bucle donde se recorre el array de bytes y se calcula el checksum.<br />
<br />
<br />
🖕  💢  😠  𝓁𝒾𝒷𝓇𝑒𝓇𝒾𝒶/𝒸𝒶𝒷𝑒𝒸𝑒𝓇𝒶 𝓊𝓈𝑒𝓇𝐼𝓃𝒻𝑜  😠  💢  🖕<br />
Esta librería alberga dos funciones dirigidas hacia la creación/gestión de ficheros.
<br />
<br />
𝙁𝙪𝙣𝙘𝙞ó𝙣 𝙘𝙧𝙚𝙖𝙩𝙚𝙐𝙨𝙚𝙧𝙄𝙣𝙛𝙤<br />
Objetivo ->  asignar dinámicamente memoria para structs y devuelve un puntero a la memoria asignada.<br />
<br />
Parámetros -> esta función solo requiere del número inicial de structs a los cuales se les asignará memoria.<br />
<br />
<br />
𝙁𝙪𝙣𝙘𝙞ó𝙣 𝙛𝙞𝙡𝙡𝙐𝙨𝙚𝙧𝙄𝙣𝙛𝙤<br />
Objetivo -> que el usuario introduzca los datos de una nueva cuenta, almacenándolos en una estructura del tipo “userInfo”.<br />
<br />
Parámetros -> esta función solo requiere un puntero a un struct “userInfo”.<br />
<br />
La función comienza pidiendo al usuario que introduzca un nombre de usuario y contraseña para posteriormente rellenar el struct con la información aportada, reservando memoria para ello.<br />
<br />
<br />
𝙁𝙪𝙣𝙘𝙞ó𝙣 𝙛𝙧𝙚𝙚𝘼𝙡𝙡𝙐𝙨𝙚𝙧𝙄𝙣𝙛𝙤<br />
Objetivo -> liberar toda memoria no usada tras asignarla dinámicamente en funciones anteriores.<br />
<br />
Parámetros -> esta función requiere de un puntero a un struct “userInfo” y la cantidad de nombres de usuario y contraseñas creadas.<br />
<br />
La función consiste en un único bucle donde se llama a una función auxiliar donde se libera la memoria no utilizada al introducir el nombre de usuario y la contraseña dentro de un struct. <br />
<br />
<br />
𝙁𝙪𝙣𝙘𝙞ó𝙣 𝙙𝙚𝙡𝙚𝙩𝙚𝙐𝙨𝙚𝙧<br />
Objetivo -> eliminar un determinado usuario, ocupando el espacio en caso de quedar libre con el resto de los elementos del array.<br />
<br />
Parámetros -> esta función requiere de un puntero a un struct “userInfo” y la cantidad de nombres de usuario y contraseñas creadas, además del índice que el usuario quiere borrar.<br />
<br />
La función comienza verificando si el índice introducido por el usuario es un índice válido, para después llamar a la función freeUserInfo para liberar la memoria del usuario ocupando el índice a borrar. Tras reorganizar el array y restarle 1 al número de nombres de usuario, se ajusta la memoria asignada al array al nuevo número de usuarios.<br />
<br />
<br />
Por último, la sección 🎀💟𝓺𝓾𝓮 𝓹𝓮𝓵𝓸𝓽𝓪𝓼 𝓮𝓼𝓽𝓸𝔂 𝓱𝓪𝓬𝓲𝓮𝓷𝓭𝓸😍❤️
<br />
✨la mierda de interfaz gráfica✨
<br />
<br />
En primer lugar, para empezar con esta interfaz, se añadirán un par de etiquetas donde se escribirá “Introduce su usuario/contraseña”, acompañadas de un par de cuadros de texto donde el usuario lo introducirá y un botón que confirme la acción. <br />
<br />
Se quiere que determinadas partes del código permanezcan ocultas hasta que se haya realizado alguna acción (se le de clic al botón de confirmar de “Introduce su usuario”, por ejemplo), por lo que cambiaremos desde el cuadro de la derecha la propiedad “Visibilidad” de los tres objetos que queremos inicialmente ocultos a “Falso”.<br />
<br />
Al hacer click al objeto que queremos que ejecute código aparecerá el lugar donde introducir ese respectivo código. Aparecen 4 ficheros diferentes, el entorno gráfico que ya se ha visto, “Form1.cs”, donde se almacena el código del entorno gráfico, “Form1.Designer” traduce automáticamente a código las acciones que se realizan en el entorno gráfico como arrastrar un botón a una determinada posición, cambiar propiedades, etc. “Program.cs” sería un equivalente al main de Clion, es el lugar donde se declaran variables globales y se aloja el código que lanza en primer lugar el formulario. En cuanto a las variables globales, estas van definidas dentro de una clase.<br />
<br />
<br />
🎀💟𝓱𝓪𝓬𝓲𝓮𝓷𝓭𝓸 𝓮𝓼𝓽𝓸 𝓭𝓮 𝓪𝓫𝓪𝓳𝓸 𝓷𝓾𝓷𝓬𝓪 𝓱𝓮 𝓽𝓮𝓷𝓲𝓭𝓸 𝓶𝓪𝓼 𝓰𝓪𝓷𝓪𝓼 𝓭𝓮 𝓶𝓮𝓽𝓮𝓻 𝓵𝓪 𝓬𝓪𝓫𝓮𝔃𝓪 𝓪𝓵 𝓶𝓲𝓬𝓻𝓸𝓸𝓷𝓭𝓪𝓼😍❤️
<br />
<br />
Primero, es importante mencionar que la interfaz gráfica no está completa por errores de falta de conocimiento sobre C#, interfaces gráficas y Visual Studio. Está completo y funciona el bloque de código de crear el fichero, añadir usuarios, listar usuarios y guardar y salir. No comprueba la contraseña maestra, existen errores en el borrado de cuentas, no calcula el checksum ni cifra. <br />
<br />
Tras añadir librerías se inicializa el Form y esta espera interacciones. La primera interacción posible es el botón “OK” para introducir el usuario maestro, si no se ha introducido texto en el cuadro de texto, el programa no continúa y aparece una etiqueta que vuelve a preguntar por el usuario. Si por el contrario se ha introducido texto, se vuelven visibles una serie de etiquetas, cuadros de texto y botones que piden la contraseña maestra. Nuevamente, al darle a “OK” tras introducirla se continúa con el programa, volviendo invisibles los objetos usados anteriormente.<br />
<br />
Tras comprobar la existencia del fichero, lo abre en modo lectura. La lógica de esta parte del código y de otras varias es muy parecida si no igual a la presentada en C en Clion, traducida a C#. En esta parte del código aparecen varios “MessageBox” y otras cosas que sirven para depurar. Si el fichero no existe, lo crea y añade en la primera línea el usuario y la contraseña maestras, separadas por un carácter “/”, además de volver visibles las siguientes partes del programa: listar, añadir y borrar usuarios y salir.<br />
<br />
Posteriormente, aparece un intento de cifrado con la misma funcionalidad XOR que no se ha logrado implementar por incapacidad de convertir los tipos de datos para que “%” y “^” funcionen.<br />
<br />
Por último, tenemos el desarrollo de la lógica de cada opción disponible. Esta lógica es muy parecida a la que se ha visto en C, añadiendo partes de código propias de C#, “traduciendo” un lenguaje a otro.<br />
<br />
“Listar Usuarios” abre un listBox y presenta los usuarios añadidos. El programa lee línea a línea, y deshecha a partir del carácter separador “/” para que no aparezcan las contraseñas.<br /> 
<br />
“Añadir Usuario” lee el fichero, añade la información introducida por el usuario en objetos ya utilizados previamente (cambiando las etiquetas) y cierra el fichero. El programa, al leer información la almacena en una cadena de strings llamado “líneas”. Al escribirlo en el fichero es vital añadir un salto de línea para que se almacene un solo usuario/contraseña por línea.<br />
<br />
“Borrar Usuario” permite seleccionar un usuario del listBox y lo borra. Sin embargo, añade un usuario más al final del fichero. Este bloque de código se nos ha dificultado más, y no se ha podido corregir el error por falta de conocimientos.<br />
<br />
“Guardar y salir” sale del programa.
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
muchas gracias Enrique por ser tan buen profe <3. has sido maravilloso, ojalá todos tuvieran tanta suerte como nosotros y su primer contacto con la universidad sea tan maravilloso. realmente te tenemos mucho cariño, ojalá todo te salga bien. muak, alejandro, ángela y alba. 
<br />
<br />
gracias a tí nuestra razón número 13 es más 12,5

